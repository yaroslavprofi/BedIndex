Так как у нас не меняется файл, то можно не строить дерево, а обойтись отсортированным массивом + бинпоиском. Основная часть решения и есть написание сортировки и бинарного поиска для файла во внешней памяти. Размер индекс файлов - `O(N)`, сортировка, работает за `O(N log2(N/B))`, бинпоиск - за `O(log2(N))`, где `N` - размер файла, `B` - размер блока, который определяет размер буфера с данными в оперативной памяти и который я указываю в файле `Constants.kt`. Так же для написания сортировки были написаны вспомогательные `Reader`'ы и `Writer`, а так же парсеры для `BedEntry` и вспомогательного `IndexEntry` . Для тестов был написан `DummyBedFinder`, который проходится по всему `Bed` файлу и за `O(N)` находит ответ, и затем этот результат сравнивается с ответом, найденным `BedReaderClass` реализующим `BedReader`.